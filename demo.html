<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PicTex JS Interactive Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .main-container {
            display: flex;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 1400px;
            width: 100%;
            flex: 1;
            overflow: hidden;
        }

        .controls {
            flex: 0 0 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .preview {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e9e9e9;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        canvas {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"],
        select,
        input[type="color"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .row {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.secondary:hover {
            background-color: #5a6268;
        }

        button.danger {
            background-color: #dc3545;
        }

        button.danger:hover {
            background-color: #c82333;
        }

        .selected-controls {
            border: 2px solid #007bff;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
        }

        .no-selection {
            text-align: center;
            color: #888;
            padding: 20px;
            font-style: italic;
        }
    </style>
</head>

<body>

    <h1>PicTex JS Interactive Editor</h1>

    <div class="main-container">
        <div class="controls">
            <div class="control-group">
                <label>Base Image</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <button id="addTextBtn" class="secondary">+ Add New Text</button>
            <button id="downloadBtn" style="background-color: #28a745;">Download Image</button>

            <hr>

            <div id="textControls" class="selected-controls" style="display: none;">
                <h3>Selected Text Properties</h3>

                <div class="control-group">
                    <label>Content</label>
                    <input type="text" id="textContent">
                </div>

                <div class="row">
                    <div class="control-group" style="flex:1">
                        <label>Font Size</label>
                        <input type="number" id="fontSize">
                    </div>
                    <div class="control-group" style="flex:1">
                        <label>Color</label>
                        <input type="color" id="textColor">
                    </div>
                </div>

                <div class="control-group">
                    <label>Font Family</label>
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Impact">Impact</option>
                        <option value="Times New Roman">Times New Roman</option>
                    </select>
                </div>

                <label>Shadow Effects</label>
                <div class="row">
                    <div class="control-group" style="flex:1">
                        <label>Blur</label>
                        <input type="number" id="shadowBlur">
                    </div>
                    <div class="control-group" style="flex:1">
                        <label>Color</label>
                        <input type="color" id="shadowColor">
                    </div>
                </div>

                <div class="control-group" style="margin-top: 10px;">
                    <button id="deleteTextBtn" class="danger">Delete Selected</button>
                </div>
            </div>

            <div id="noSelectionMsg" class="no-selection">
                Select a text item to edit its properties.
            </div>
        </div>

        <div class="preview" id="previewContainer">
            <!-- Canvas will be injected here -->
        </div>
    </div>

    <script type="module">
        import { PicTexCanvas, ImageNode, Text, Shadow, Group } from './pictex.js';

        // State
        let imageNode = null;
        let textNodes = [];
        let selectedNode = null;
        let renderer = new PicTexCanvas();
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let nodeStart = { x: 0, y: 0 };

        // DOM Elements
        const previewContainer = document.getElementById('previewContainer');
        const controlsPanel = document.getElementById('textControls');
        const noSelectionMsg = document.getElementById('noSelectionMsg');

        // Inputs
        const inputs = {
            content: document.getElementById('textContent'),
            fontSize: document.getElementById('fontSize'),
            color: document.getElementById('textColor'),
            fontFamily: document.getElementById('fontFamily'),
            shadowBlur: document.getElementById('shadowBlur'),
            shadowColor: document.getElementById('shadowColor'),
        };

        // Initial Setup
        async function init() {
            // Load default image
            imageNode = new ImageNode('https://images.unsplash.com/photo-1472214103451-9374bd1c798e?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80');
            await imageNode.load();

            // Add initial text
            addText("Hello World", 100, 100);

            // Setup Canvas
            previewContainer.appendChild(renderer.canvas);

            // Bind Canvas Events
            renderer.canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);

            render();
        }

        function addText(content = "New Text", x = 50, y = 50) {
            const text = new Text(content)
                .fontSize(60)
                .fontFamily('Arial')
                .color('#ffffff')
                .textShadows(new Shadow({ blurRadius: 10, color: '#000000', offset: [2, 2] }));

            text._x = x;
            text._y = y;

            textNodes.push(text);
            selectNode(text);
            render();
        }

        function selectNode(node) {
            selectedNode = node;
            updateUI();
            render(); // Re-render to show selection indicator (if we implement one)
        }

        function updateUI() {
            if (selectedNode) {
                controlsPanel.style.display = 'block';
                noSelectionMsg.style.display = 'none';

                // Populate inputs
                inputs.content.value = selectedNode.content;
                inputs.fontSize.value = selectedNode._fontSize;
                inputs.color.value = selectedNode._color;
                inputs.fontFamily.value = selectedNode._fontFamily;

                const shadow = selectedNode._textShadows[0] || new Shadow();
                inputs.shadowBlur.value = shadow.blurRadius;
                inputs.shadowColor.value = shadow.color;
            } else {
                controlsPanel.style.display = 'none';
                noSelectionMsg.style.display = 'block';
            }
        }

        function updateSelectedNode() {
            if (!selectedNode) return;

            selectedNode.content = inputs.content.value;
            selectedNode.fontSize(parseInt(inputs.fontSize.value));
            selectedNode.color(inputs.color.value);
            selectedNode.fontFamily(inputs.fontFamily.value);

            // Update Shadow
            selectedNode._textShadows = [
                new Shadow({
                    blurRadius: parseInt(inputs.shadowBlur.value),
                    color: inputs.shadowColor.value,
                    offset: [2, 2]
                })
            ];

            render();
        }

        // Event Handlers
        function getCanvasCoordinates(e) {
            const rect = renderer.canvas.getBoundingClientRect();
            const scaleX = renderer.canvas.width / rect.width;
            const scaleY = renderer.canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function handleMouseDown(e) {
            const coords = getCanvasCoordinates(e);

            // Check hit test in reverse order (top to bottom)
            let hit = null;
            for (let i = textNodes.length - 1; i >= 0; i--) {
                if (textNodes[i].hitTest(coords.x, coords.y)) {
                    hit = textNodes[i];
                    break;
                }
            }

            if (hit) {
                selectNode(hit);
                isDragging = true;
                dragStart = coords;
                nodeStart = { x: hit._x, y: hit._y };
            } else {
                selectedNode = null;
                updateUI();
                render();
            }
        }

        function handleMouseMove(e) {
            if (isDragging && selectedNode) {
                const coords = getCanvasCoordinates(e);
                const dx = coords.x - dragStart.x;
                const dy = coords.y - dragStart.y;

                selectedNode._x = nodeStart.x + dx;
                selectedNode._y = nodeStart.y + dy;

                render();
            }
        }

        function handleMouseUp() {
            isDragging = false;
        }

        // Render Loop
        async function render() {
            const root = new Group();
            root.add(imageNode);
            textNodes.forEach(node => root.add(node));

            await renderer.render(root);

            // Draw selection border
            if (selectedNode) {
                const ctx = renderer.ctx;
                ctx.save();
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    selectedNode._x,
                    selectedNode._y,
                    selectedNode._computedWidth,
                    selectedNode._computedHeight
                );
                ctx.restore();
            }
        }

        // Listeners
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    imageNode = new ImageNode(event.target.result);
                    imageNode.load().then(render);
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('addTextBtn').addEventListener('click', () => addText());

        document.getElementById('deleteTextBtn').addEventListener('click', () => {
            if (selectedNode) {
                textNodes = textNodes.filter(n => n !== selectedNode);
                selectedNode = null;
                updateUI();
                render();
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            // Render without selection box
            const root = new Group();
            root.add(imageNode);
            textNodes.forEach(node => root.add(node));

            // We need a clean render for download
            // Since renderer.render is async and modifies the canvas, 
            // we can just call it, wait, then download.
            // But we need to make sure we don't draw the selection box.
            // A quick hack is to temporarily clear selection, render, download, restore selection.

            const tempSelection = selectedNode;
            selectedNode = null;
            render().then(() => {
                const link = document.createElement('a');
                link.download = 'pictex-result.png';
                link.href = renderer.canvas.toDataURL();
                link.click();

                selectedNode = tempSelection;
                render();
            });
        });

        // Bind inputs
        Object.values(inputs).forEach(input => {
            input.addEventListener('input', updateSelectedNode);
        });

        // Start
        init();

    </script>
</body>

</html>