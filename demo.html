<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PicTex JS Interactive Editor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .main-container {
            display: flex;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 1400px;
            width: 100%;
            flex: 1;
            overflow: hidden;
        }

        .controls {
            flex: 0 0 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .preview {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e9e9e9;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        canvas {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        input[type="text"],
        input[type="number"],
        select,
        input[type="color"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .row {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.secondary:hover {
            background-color: #5a6268;
        }

        button.danger {
            background-color: #dc3545;
        }

        button.danger:hover {
            background-color: #c82333;
        }

        .selected-controls {
            border: 2px solid #007bff;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
        }

        .no-selection {
            text-align: center;
            color: #888;
            padding: 20px;
            font-style: italic;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <h1>PicTex JS Interactive Editor</h1>

    <div class="main-container">
        <div class="controls">
            <div class="control-group">
                <label>Base Image</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <div class="row">
                <button id="addTextBtn" class="secondary" style="flex:1">+ Add Text</button>
                <button id="addImageBtn" class="secondary" style="flex:1">+ Add Image</button>
            </div>
            <input type="file" id="overlayImageInput" accept="image/*" style="display: none;">

            <button id="downloadBtn" style="background-color: #28a745;">Download Image</button>
            <button id="exportJsonBtn" style="background-color: #17a2b8;">Export JSON</button>

            <hr>

            <div id="controlsPanel" class="selected-controls" style="display: none;">
                <h3 id="panelTitle">Selected Item Properties</h3>

                <!-- Text Specific Controls -->
                <div id="textSpecificControls">
                    <div class="control-group">
                        <label>Content</label>
                        <input type="text" id="textContent">
                    </div>

                    <div class="row">
                        <div class="control-group" style="flex:1">
                            <label>Font Size</label>
                            <input type="number" id="fontSize">
                        </div>
                        <div class="control-group" style="flex:1">
                            <label>Color</label>
                            <input type="color" id="textColor">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Font Family</label>
                        <select id="fontFamily">
                            <option value="Arial">Arial</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier New">Courier New</option>
                            <option value="Impact">Impact</option>
                            <option value="Times New Roman">Times New Roman</option>
                        </select>
                    </div>
                </div>

                <!-- Image Specific Controls -->
                <div id="imageSpecificControls" class="hidden">
                    <div class="row">
                        <div class="control-group" style="flex:1">
                            <label>Width (px)</label>
                            <input type="number" id="imgWidth">
                        </div>
                        <div class="control-group" style="flex:1">
                            <label>Height (px)</label>
                            <input type="number" id="imgHeight">
                        </div>
                    </div>
                </div>

                <hr>

                <!-- Common Styling -->
                <div class="control-group">
                    <label>Background</label>
                    <select id="bgType">
                        <option value="none">None</option>
                        <option value="solid">Solid Color</option>
                        <option value="gradient">Linear Gradient</option>
                    </select>
                </div>

                <div id="bgColorControl" class="control-group hidden">
                    <label>Background Color</label>
                    <input type="color" id="bgColor">
                </div>

                <div id="bgGradientControl" class="hidden">
                    <div class="row">
                        <div class="control-group" style="flex:1">
                            <label>Start Color</label>
                            <input type="color" id="gradStart">
                        </div>
                        <div class="control-group" style="flex:1">
                            <label>End Color</label>
                            <input type="color" id="gradEnd">
                        </div>
                    </div>
                </div>

                <div class="row">
                    <div class="control-group" style="flex:1">
                        <label>Border Radius</label>
                        <input type="number" id="borderRadius" value="0">
                    </div>
                    <div class="control-group" style="flex:1">
                        <label>Padding</label>
                        <input type="number" id="padding" value="0">
                    </div>
                </div>

                <label>Shadow Effects</label>
                <div class="row">
                    <div class="control-group" style="flex:1">
                        <label>Blur</label>
                        <input type="number" id="shadowBlur">
                    </div>
                    <div class="control-group" style="flex:1">
                        <label>Color</label>
                        <input type="color" id="shadowColor">
                    </div>
                </div>

                <div class="control-group" style="margin-top: 10px;">
                    <button id="deleteBtn" class="danger">Delete Selected</button>
                </div>
            </div>

            <div id="noSelectionMsg" class="no-selection">
                Select an item to edit its properties.
            </div>
        </div>

        <div class="preview" id="previewContainer">
            <!-- Canvas will be injected here -->
        </div>
    </div>

    <script type="module">
        import { PicTexCanvas, ImageNode, Text, Shadow, Group, LinearGradient } from './pictex.js';

        // State
        let baseImageNode = null;
        let nodes = []; // Contains Text and ImageNode overlays
        let selectedNode = null;
        let renderer = new PicTexCanvas();
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let nodeStart = { x: 0, y: 0 };

        // DOM Elements
        const previewContainer = document.getElementById('previewContainer');
        const controlsPanel = document.getElementById('controlsPanel');
        const noSelectionMsg = document.getElementById('noSelectionMsg');
        const textSpecificControls = document.getElementById('textSpecificControls');
        const imageSpecificControls = document.getElementById('imageSpecificControls');
        const overlayImageInput = document.getElementById('overlayImageInput');

        // Inputs
        const inputs = {
            // Text
            content: document.getElementById('textContent'),
            fontSize: document.getElementById('fontSize'),
            color: document.getElementById('textColor'),
            fontFamily: document.getElementById('fontFamily'),

            // Image
            imgWidth: document.getElementById('imgWidth'),
            imgHeight: document.getElementById('imgHeight'),

            // Common
            bgType: document.getElementById('bgType'),
            bgColor: document.getElementById('bgColor'),
            gradStart: document.getElementById('gradStart'),
            gradEnd: document.getElementById('gradEnd'),
            borderRadius: document.getElementById('borderRadius'),
            padding: document.getElementById('padding'),
            shadowBlur: document.getElementById('shadowBlur'),
            shadowColor: document.getElementById('shadowColor'),
        };

        // Initial Setup
        async function init() {
            // Load default image
            baseImageNode = new ImageNode('https://images.unsplash.com/photo-1472214103451-9374bd1c798e?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80');
            await baseImageNode.load();

            // Add initial text
            addText("Hello World", 100, 100);

            // Setup Canvas
            previewContainer.appendChild(renderer.canvas);

            // Bind Canvas Events
            renderer.canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);

            render();
        }

        function addText(content = "New Text", x = 50, y = 50) {
            const text = new Text(content)
                .fontSize(60)
                .fontFamily('Arial')
                .color('#ffffff')
                .textShadows(new Shadow({ blurRadius: 10, color: '#000000', offset: [2, 2] }));

            text._x = x;
            text._y = y;

            nodes.push(text);
            selectNode(text);
            render();
        }

        async function addImage(src, x = 50, y = 50) {
            const img = new ImageNode(src);
            await img.load();
            // Default size to something reasonable if too huge
            if (img._width > 300) {
                const ratio = img._height / img._width;
                img._width = 300;
                img._height = 300 * ratio;
            }

            img._x = x;
            img._y = y;

            nodes.push(img);
            selectNode(img);
            render();
        }

        function selectNode(node) {
            selectedNode = node;
            updateUI();
            render();
        }

        function updateUI() {
            if (selectedNode) {
                controlsPanel.style.display = 'block';
                noSelectionMsg.style.display = 'none';

                // Toggle specific controls
                if (selectedNode instanceof Text) {
                    textSpecificControls.classList.remove('hidden');
                    imageSpecificControls.classList.add('hidden');
                    document.getElementById('panelTitle').textContent = "Text Properties";

                    inputs.content.value = selectedNode.content;
                    inputs.fontSize.value = selectedNode._fontSize;
                    inputs.color.value = selectedNode._color;
                    inputs.fontFamily.value = selectedNode._fontFamily;
                } else if (selectedNode instanceof ImageNode) {
                    textSpecificControls.classList.add('hidden');
                    imageSpecificControls.classList.remove('hidden');
                    document.getElementById('panelTitle').textContent = "Image Properties";

                    inputs.imgWidth.value = Math.round(selectedNode._computedWidth);
                    inputs.imgHeight.value = Math.round(selectedNode._computedHeight);
                }

                // Common Properties
                inputs.borderRadius.value = selectedNode._borderRadius;
                inputs.padding.value = selectedNode._padding;

                // Background Logic
                const bg = selectedNode._backgroundColor;
                if (bg instanceof LinearGradient) {
                    inputs.bgType.value = 'gradient';
                    inputs.gradStart.value = bg.colors[0];
                    inputs.gradEnd.value = bg.colors[bg.colors.length - 1];
                } else if (bg) {
                    inputs.bgType.value = 'solid';
                    inputs.bgColor.value = bg;
                } else {
                    inputs.bgType.value = 'none';
                }
                toggleBgControls();

                // Shadow
                const shadow = (selectedNode._shadows && selectedNode._shadows[0]) ||
                    (selectedNode._textShadows && selectedNode._textShadows[0]) ||
                    new Shadow();
                inputs.shadowBlur.value = shadow.blurRadius;
                inputs.shadowColor.value = shadow.color;

            } else {
                controlsPanel.style.display = 'none';
                noSelectionMsg.style.display = 'block';
            }
        }

        function toggleBgControls() {
            const type = inputs.bgType.value;
            document.getElementById('bgColorControl').classList.add('hidden');
            document.getElementById('bgGradientControl').classList.add('hidden');

            if (type === 'solid') {
                document.getElementById('bgColorControl').classList.remove('hidden');
            } else if (type === 'gradient') {
                document.getElementById('bgGradientControl').classList.remove('hidden');
            }
        }

        function updateSelectedNode() {
            if (!selectedNode) return;

            if (selectedNode instanceof Text) {
                selectedNode.content = inputs.content.value;
                selectedNode.fontSize(parseInt(inputs.fontSize.value));
                selectedNode.color(inputs.color.value);
                selectedNode.fontFamily(inputs.fontFamily.value);
            } else if (selectedNode instanceof ImageNode) {
                selectedNode._width = parseInt(inputs.imgWidth.value);
                selectedNode._height = parseInt(inputs.imgHeight.value);
            }

            // Common
            selectedNode.borderRadius(parseInt(inputs.borderRadius.value));
            selectedNode.padding(parseInt(inputs.padding.value));

            // Background
            const bgType = inputs.bgType.value;
            if (bgType === 'none') {
                selectedNode.backgroundColor(null);
            } else if (bgType === 'solid') {
                selectedNode.backgroundColor(inputs.bgColor.value);
            } else if (bgType === 'gradient') {
                selectedNode.backgroundColor(new LinearGradient({
                    colors: [inputs.gradStart.value, inputs.gradEnd.value]
                }));
            }

            // Shadow
            const shadow = new Shadow({
                blurRadius: parseInt(inputs.shadowBlur.value),
                color: inputs.shadowColor.value,
                offset: [2, 2]
            });

            if (selectedNode instanceof Text) {
                selectedNode._textShadows = [shadow];
            } else {
                selectedNode._shadows = [shadow];
            }

            render();
        }

        // Event Handlers
        function getCanvasCoordinates(e) {
            const rect = renderer.canvas.getBoundingClientRect();
            const scaleX = renderer.canvas.width / rect.width;
            const scaleY = renderer.canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function handleMouseDown(e) {
            const coords = getCanvasCoordinates(e);

            // Check hit test in reverse order (top to bottom)
            let hit = null;
            for (let i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].hitTest(coords.x, coords.y)) {
                    hit = nodes[i];
                    break;
                }
            }

            if (hit) {
                selectNode(hit);
                isDragging = true;
                dragStart = coords;
                nodeStart = { x: hit._x, y: hit._y };
            } else {
                selectedNode = null;
                updateUI();
                render();
            }
        }

        function handleMouseMove(e) {
            if (isDragging && selectedNode) {
                const coords = getCanvasCoordinates(e);
                const dx = coords.x - dragStart.x;
                const dy = coords.y - dragStart.y;

                selectedNode._x = nodeStart.x + dx;
                selectedNode._y = nodeStart.y + dy;

                render();
            }
        }

        function handleMouseUp() {
            isDragging = false;
        }

        // Render Loop
        async function render() {
            const root = new Group();
            root.add(baseImageNode);
            nodes.forEach(node => root.add(node));

            await renderer.render(root);

            // Draw selection border
            if (selectedNode) {
                const ctx = renderer.ctx;
                ctx.save();
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    selectedNode._x,
                    selectedNode._y,
                    selectedNode._computedWidth,
                    selectedNode._computedHeight
                );
                ctx.restore();
            }
        }

        // Listeners
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    baseImageNode = new ImageNode(event.target.result);
                    baseImageNode.load().then(render);
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('addTextBtn').addEventListener('click', () => addText());

        document.getElementById('addImageBtn').addEventListener('click', () => {
            overlayImageInput.click();
        });

        overlayImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    addImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
            // Reset input so same file can be selected again
            overlayImageInput.value = '';
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedNode) {
                nodes = nodes.filter(n => n !== selectedNode);
                selectedNode = null;
                updateUI();
                render();
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const tempSelection = selectedNode;
            selectedNode = null;
            render().then(() => {
                const link = document.createElement('a');
                link.download = 'pictex-result.png';
                link.href = renderer.canvas.toDataURL();
                link.click();

                selectedNode = tempSelection;
                render();
            });
        });

        document.getElementById('exportJsonBtn').addEventListener('click', () => {
            if (!baseImageNode) return;

            const baseWidth = baseImageNode._computedWidth;
            const baseHeight = baseImageNode._computedHeight;

            const exportData = {
                base_image: baseImageNode.src,
                elements: nodes.map(node => {
                    let shadowObj = null;
                    if (node instanceof Text) {
                        shadowObj = node._textShadows && node._textShadows[0];
                    } else {
                        shadowObj = node._shadows && node._shadows[0];
                    }

                    const common = {
                        type: node instanceof Text ? 'text' : 'image',
                        x: (node._x / baseWidth * 100).toFixed(2) + '%',
                        y: (node._y / baseHeight * 100).toFixed(2) + '%',
                        padding: node._padding,
                        border_radius: node._borderRadius,
                        background: node._backgroundColor instanceof LinearGradient ? {
                            type: 'linear_gradient',
                            colors: node._backgroundColor.colors
                        } : node._backgroundColor,
                        shadow: shadowObj ? {
                            blur: shadowObj.blurRadius,
                            color: shadowObj.color,
                            offset: shadowObj.offset
                        } : null
                    };

                    if (node instanceof Text) {
                        return {
                            ...common,
                            content: node.content,
                            font_size: (node._fontSize / baseHeight * 100).toFixed(2) + '%', // Relative to height
                            font_family: node._fontFamily,
                            color: node._color
                        };
                    } else {
                        return {
                            ...common,
                            src: node.src,
                            width: (node._computedWidth / baseWidth * 100).toFixed(2) + '%',
                            height: (node._computedHeight / baseHeight * 100).toFixed(2) + '%'
                        };
                    }
                })
            };

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "pictex_export.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        inputs.bgType.addEventListener('change', () => {
            toggleBgControls();
            updateSelectedNode();
        });

        // Bind inputs
        Object.values(inputs).forEach(input => {
            if (input) input.addEventListener('input', updateSelectedNode);
        });

        // Start
        init();

    </script>
</body>

</html>